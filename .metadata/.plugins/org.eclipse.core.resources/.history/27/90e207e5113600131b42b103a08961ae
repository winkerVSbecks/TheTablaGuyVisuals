/**********************************************************************************************

 	Each scene consists of the following parameter:
 		- Expected MIDI notes to monitor (coming from Ableton)
 		- Audio channel to monitor
 		- The type of visuals to render

**********************************************************************************************/	

import java.util.ArrayList;

import processing.core.PApplet;
import processing.core.PVector;

public class PyramidScene {
	
	int t;
	int[] range;
	Note[] notes;
	PApplet p;
	String name;
	ArrayList<Cluster> clusters;
	FlyingPyramid lonePyramid;
	Icosahedron isoIcosahedron;
	
//	int colors[] = { 0xFF1ABC9C, 0xFF2ECC71, 0xFFE74C3C, 0xFF16A085,
//					 0xFFF1C40F, 0xFFE67E22, 0xFF3498DB,  0xFF9B59B6,
//					 0xFF27AE60, 0xFF2980B9, 0xFF8E44AD, 0xFFF39C12,
//					 0xFFD35400, 0xFFC0392B };  
	
	int colors[] = { 0xFF2ECC71, 0xFF3498DB, 0xFF9B59B6, 0xFF34495E,
					 0xFFF1C40F, 0xFFE67E22, 0xFFE74C3C, 0xFF95A5A6,
					 0xFFAB948C, 0xFFF2F2F2, 0xFFFBD199, 0xFF981B48,
					 0xFFFBF6A7, 0xFFF8B39B };  
	
	public PyramidScene(PApplet _p, String _name, Note[] _notes, int[] _range, int _t) {
		name = _name;
		p = _p;
		notes = _notes;
		range = _range;
		t = _t;
		// Build clusters
		clusters = new ArrayList<Cluster>();
		for (int i = 0; i < range.length; i++) {
			Note note = notes[range[i]];
			clusters.add( new Cluster(p, note, colors[i], i) );
		}
		// Build lone pyramid
		float r = p.random(25, 200);
	    float f = p.random(2, 5);
	    lonePyramid = new FlyingPyramid(p, f*r, r);
	}
	
	public void draw() {
//		p.background(0xFFECF0F1);
		p.background(255, 255, 250);
		if(Properties.LONE_PYRAMID) {
			lonePyramid.update(notes[range[0]].getAttack());
			PApplet.println(notes[range[0]].getAttack());
		} else {
			for(Cluster cluster: clusters) {
				cluster.draw();
			}
		}
	}
	
	public void createIcosahedron(int level) {  // the icosahedron is created with positions, normals and texture coordinates in the above class
	  Icosahedron ico = new Icosahedron (p, level);
	  PImage tex = p.loadImage("world32k.jpg"); // load the texture
	  PShape mesh = p.createShape(); // create the initial PShape
	  mesh.beginShape(TRIANGLES); // define the PShape type: TRIANGLES
	  mesh.noStroke();
	  mesh.texture(tex); // set the texture
	  // put all the vertices, uv texture coordinates and normals into the PShape
	  for (int i=0; i<ico.positions.size(); i++) {
	    PVector p = ico.positions.get(i);
	    PVector t = ico.texCoords.get(i);
	    PVector n = ico.normals.get(i);
	    mesh.normal(n.x, n.y, n.z);
	    mesh.vertex(p.x, p.y, p.z, t.x, t.y);
	  }
	  mesh.endShape();

	  return mesh;
	}
}
