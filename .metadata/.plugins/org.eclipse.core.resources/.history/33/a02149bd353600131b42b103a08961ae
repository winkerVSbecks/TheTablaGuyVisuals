
import processing.core.PApplet;
import processing.core.PVector;
import processing.core.PConstants;

public class LonePyramid {
	PApplet p;
	PVector[] v;
	int[] cp = new int[14]; 
	int[] c = new int[14]; 
	float origPyHeight, origPyRadius;
	float pyHeight, pyRadius;
	float transparency; 
	PVector pos; 
	float rotX, rotY, rotZ; 
	float MAXSPEED = 50;
	float scl = 1.0f;

	LonePyramid(PApplet _p, float _pyHeight, float _pyRadius, int[] _c) {
		
		p = _p;
		v = new PVector[5];
		pyHeight = _pyHeight;
		origPyHeight = pyHeight;  //spread out -> p.random(3.0f, 7.0f)*pyHeight; 
		pyRadius = 2.0f*_pyRadius;
		origPyRadius = pyRadius; 
		// point all over the place -> pos = new PVector(p.width/2+p.random(-p.width, p.width), p.height/2+p.random(-p.height, p.height), -1000);
		pos = new PVector(p.width/2, p.height/2, -2000);
		transparency = 255;
		rotX = p.random(-2*p.width, 3*p.width); 
		rotY = p.random(-2*p.height, 2*p.height);
		rotZ = p.random(-2*p.width, 3*p.width);
		c = _c;
		updatePyramid();
		reColor();
	}

	void updatePyramid() {
		float base, top;
		
		if(Properties.IS_INWARD) { base = origPyHeight + pyHeight/3; top = origPyHeight - 2*pyHeight/3; }
		else { base = origPyHeight - pyHeight/3; top = origPyHeight + 2*pyHeight/3;  }
				
		v[0] = new PVector(0, top, 0);
		v[1] = new PVector(pyRadius*PApplet.cos(PConstants.HALF_PI), base, pyRadius*PApplet.sin(PConstants.HALF_PI));  // base point 1
		v[2] = new PVector(pyRadius*PApplet.cos(PConstants.PI), base, pyRadius*PApplet.sin(PConstants.PI));            // base point 2
		v[3] = new PVector(pyRadius*PApplet.cos(1.5f*PConstants.PI), base, pyRadius*PApplet.sin(1.5f*PConstants.PI));  // base point 3
		v[4] = new PVector(pyRadius*PApplet.cos(PConstants.TWO_PI), base, pyRadius*PApplet.sin(PConstants.TWO_PI));    // base point 4

		
		// Normalize base points to the surface of a sphere
		for (int i = 1; i < v.length; i++) {
			v[i].normalize();
			v[i].mult(base);
		}
		// Do the same for the top
		v[0].normalize();
		v[0].mult(top);
	}

	void update(float d) {		
		//scale it instead Ð no pyramid update needed
		scl = 1.0f+d*0.75f;
		// Display all pyramids/only the ones which were triggered
		display(d);
		// change colors
		if(p.frameCount % 240 == 0) reColor();
	}
	
	void display(float d) {
		transparency = 175;
 		p.pushMatrix(); 
			p.translate(pos.x, pos.y, -2000);
			p.scale(scl);
			// Rotate pyramids
			if(Properties.DO_ROTATE_PYRAMIDS) {
				p.rotateY(rotY + p.frameCount*0.02f); 
				p.rotateX(rotX + p.frameCount*0.01f); 
				p.rotateZ(rotZ + p.frameCount*0.01f);
			} else {
				p.rotateY(rotY); 
				p.rotateX(rotX); 
				p.rotateZ(rotZ); 
			}
			// draw the 4 side triangles of the pyramid
//			if(d>0.5) {
//				p.stroke(0xFFECF0F1);
//			} else {
//				p.stroke(255, 15);
//			}
			p.stroke(255, 25);
			p.beginShape(PConstants.TRIANGLE_FAN); 
				for (int i=0; i<5; i++) {
					p.vertex(v[i].x, v[i].y, v[i].z); 
				}
				// add the 'first base vertex' to close the shape
				p.vertex(v[1].x, v[1].y, v[1].z, 0.0f, 0.0f);
			p.endShape(); 
			// draw the base quad of the pyramid
			p.beginShape(PConstants.QUADS);
				for (int i=1; i<5; i++) {
					p.vertex(v[i].x, v[i].y, v[i].z);
				}
			p.endShape(); 
		p.popMatrix(); 
	}
	
	void reColor() {
		for (int i = 0; i < c.length; i++) {
			c[i] = cp[(int)p.random(13)];
		}
	}

}
